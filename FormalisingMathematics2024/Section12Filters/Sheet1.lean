/-
Copyright (c) 2023 Kevin Buzzard. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author : Kevin Buzzard
-/
import Mathlib.Tactic
-- imports all the Lean tactics
import Mathlib.Order.Filter.Basic

/-!

# Filters

## What is a filter?

Morally, a filter on a type `Î±` is a "generalised subset of `Î±`". By this I mean that each subset
of `Î±` gives rise to a filter, but there are other "ideas", such as "an infinitesimal neighbourhood of
a point in a topological space" or "a neighbourhood of infinity in a totally ordered set", which can be
expressed as filters but not as sets (Isaac Newton might have wanted to have `dx` as "a real number
infinitesimally close to 0", but the modern treatments of real numbers don't allow `dx` as elements;
filters enable you to recover these thoughts)

The property which we want a "generalised subset" to have, is that it is uniquely determined
by the *actual* subsets which it's contained in. Let's use this point of view to figure
out the definition of a filter.

If `F` is a "generalised subset" of a type `Î±`, then then what properties should
the collection of *actual* subsets of `Î±` which contain `F` have?

1) If `S` contains `F` and `S âŠ† T` then `T` contains `F`.
2) If `S` and `T` contain `F`, then so does `S âˆ© T`
3) The set `Î±` itself (or, in Lean speak, `Set.univ : set Î±`) contains `F`.

The way that these "generalised subsets" of `Î±` are modelled is precisely as collections
of subsets of `Î±` satisfying these three axioms.

## The formal definition

```lean
structure Filter (Î± : Type*) where
  sets : Set (Set Î±)
  univ_sets : Set.univ âˆˆ sets
  sets_of_superset {x y} : x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets
  inter_sets {x y} : x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets
```

In other words, to give a filter on a type `Î±` is to give a set of subsets of `Î±` satisfying
the three axioms above.

Some people add in an extra fourth axiom, saying that the empty set is not allowed to
be in `sets`. This is a way of saying that the empty set is not allowed to be a
generalised subset of `Î±`. But it's certainly a subset of `Î±`, so in mathlib we do not
include this fourth axiom. To me this missing axiom feels analogous to an axiom saying
that e.g. a ring is not allowed to be an ideal of itself; it might seem initially like
a good idea (because then "maximal ideals" really are maximal elements in the set of
ideals) but it causes a lot of confusion later on because you have to constantly deal
with the special case which you've disallowed.

## Notation, helpful tactics and helpful theorems

We are not going to build filters from first principles, we will be
using Lean's API for filters.

Say `Î± : Type` and `F : Filter Î±` and `S : Set Î±`. The notation `S âˆˆ F` is
defined to mean `S âˆˆ F.sets`. You should think of it as morally meaning `F âŠ† S`,
but this doesn't make sense because `F` is a filter, not a subset.

The `ext` tactic can be used to reduce a goal `F = G` to a goal of
the form `âˆ€ S, S âˆˆ F â†” S âˆˆ G`.

The fields of the structure mention things like `S âˆˆ F.sets`, so the
axioms are restated with different names, but using the `S âˆˆ F` notation.
The lemmas corresponding to the definitions are:

`univ_mem : univ âˆˆ F`
`mem_of_superset : S âˆˆ F â†’ S âŠ† T â†’ T âˆˆ F`
`inter_mem : S âˆˆ F â†’ T âˆˆ F â†’ S âˆ© T âˆˆ F`

These lemmas in the `Filter` namespace, i.e. their full names are
`Filter.univ_mem_sets` etc. But we are about to say `open Filter`
which means that you don't have to type this `Filter.` thing in front of every
lemma you need about filters. In fact we'll also be using a bunch of
stuff about sets, like `Set.inter_subset_left`, so why don't we `open Set`
as well.
-/

namespace Section12sheet1

open Filter Set

-- Variables!
-- let `Î±` be a type, let `F` be a filter on `Î±`, and let `S` and `T`
-- denote subsets of `Î±`.
variable (Î± : Type) (F : Filter Î±) (S T : Set Î±)

/-
Here's a lemma about filters: Two sets `S` and `T` are both in
a filter `F` if and only if their intersection is. See if you can deduce
it from the axioms of a filter.

For this one it's useful to know the following results (from the set namespace)
`inter_subset_left S T : S âˆ© T âŠ† S`
and
`inter_subset_right S T : S âˆ© T âŠ† S`
-/
example : S âˆ© T âˆˆ F â†” S âˆˆ F âˆ§ T âˆˆ F := sorry

/-

## Principal filters

Surely a subset of `Î±` should be a generalised subset of `Î±`! So there
should be a map `Set Î± â†’ Filter Î±`. It's called `principal` and it
has notation `ğ“Ÿ`. The principal filter `ğ“Ÿ X` generated by `X : set Î±` is the
subsets of `Î±` which contain `X`. Prove that it's a filter.

Helpful for this exercise:
`mem_univ s : s âˆˆ univ`
`Subset.trans : A âŠ† B â†’ B âŠ† C â†’ A âŠ† C`
`subset_inter : X âŠ† S â†’ X âŠ† T â†’ X âŠ† S âˆ© T`
(note that you could probably prove those last two things directly yourself,
but we may as well use the interface for sets given that it's there)
`mem_setOf_eq : x âˆˆ {a : Î± | p a} = p x`
(this one is definitional, so you could use `change` instead, or just
not rewrite it at all)

-/
-- this is called `ğ“Ÿ X` in mathlib but let's just make it ourselves.
example (X : Set Î±) : Filter Î± where
  sets := { S | X âŠ† S }
  univ_sets := sorry
  sets_of_superset := sorry
  inter_sets := sorry

-- The notation for the principal filter generated by `X : set Î±` is `ğ“Ÿ X`.
-- This notation is in the "Filter" scope, which is just a posh way
-- of saying that you have to type
open scoped Filter
-- in order to get the notation.

namespace Section12sheet1
