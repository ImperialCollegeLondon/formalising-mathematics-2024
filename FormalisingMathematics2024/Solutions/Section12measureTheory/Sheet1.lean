/-
Copyright (c) 2023 Kevin Buzzard. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author : Kevin Buzzard
-/
import Mathlib.Tactic.Default
import MeasureTheory.MeasurableSpace


-- imports all the Lean tactics
-- imports all the Lean tactics
/-

# Measure theory

## Sigma algebras.

A Ïƒ-algebra on a type `X` is a collection of subsets of `X` satisfying some
axioms, and in Lean you write it like this:

-/
/-

# Measure theory

## Sigma algebras.

A Ïƒ-algebra on a type `X` is a collection of subsets of `X` satisfying some
axioms, and in Lean you write it like this:

-/
-- let X be a set
-- let X be a set
variable (X : Type)

-- ...and let ğ“ be a sigma-algebra on X
variable (ğ“ : MeasurableSpace X)

/-

Note that `measurable_space` is a *class*, so really we should be writing `[measurable_space X]`,
meaning "let `X` be equipped once and for all with a sigma algebra which we won't give a name to".
But in this sheet we'll consider making them explicitly.

Let's do the following exercise. Show that if `A` is a subset of `X` then `{0,A,Aá¶œ,X}`
is a sigma algebra on `X`.

-/
def genBy (A : Set X) : MeasurableSpace X
    where
  MeasurableSet' S := S = âˆ… âˆ¨ S = A âˆ¨ S = Aá¶œ âˆ¨ S = âŠ¤
  measurable_set_empty := by left; rfl
  measurable_set_compl := by
    rintro s (h | h | h | h)
    Â· right; right; right; simp [h]
    Â· right; right; left; rw [h]
    Â· right; left; rw [h]; simp
    Â· left; rw [h]; simp
  measurable_set_iUnion := by
    intro f hf
    by_cases h1 : âˆƒ j, f j = âŠ¤
    Â· right; right; right
      rw [eq_top_iff]
      rintro x -
      rw [Set.mem_iUnion]
      cases' h1 with j hj
      use j
      rw [hj]
      triv
    push_neg at h1 
    by_cases h2 : âˆƒ j k, f j = A âˆ§ f k = Aá¶œ
    Â· right; right; right; rw [eq_top_iff]; rintro x -
      rw [Set.mem_iUnion]
      rcases h2 with âŸ¨j, k, hj, hkâŸ©
      by_cases hxA : x âˆˆ A
      Â· use j
        rwa [hj]
      Â· use k
        rwa [hk]
    push_neg at h2 
    by_cases h3 : âˆƒ j, f j = A
    Â· right; left
      ext x
      rw [Set.mem_iUnion]
      cases' h3 with j hj
      constructor
      Â· rintro âŸ¨i, hiâŸ©
        suffices f i âŠ† A by exact this hi
        rcases hf i with (h | h | h | h)
        Â· rw [h]; simp
        Â· rw [h]
        Â· cases h2 j i hj h
        Â· cases h1 i h
      Â· intro hx
        use j
        rwa [hj]
    by_cases h4 : âˆƒ j, f j = Aá¶œ
    Â· right; right; left
      ext x
      rw [Set.mem_iUnion]
      cases' h4 with j hj
      constructor
      Â· rintro âŸ¨i, hiâŸ©
        suffices f i âŠ† Aá¶œ by exact this hi
        rcases hf i with (h | h | h | h)
        Â· rw [h]; simp
        Â· cases h2 i j h hj
        Â· rw [h]; simp
        Â· cases h1 i h
      Â· intro hx
        use j
        rwa [hj]
    push_neg at h3 h4 
    left
    apply Set.eq_empty_of_subset_empty
    intro x hx
    rw [Set.mem_iUnion] at hx 
    cases' hx with i hi
    rcases hf i with (h | h | h | h)
    Â· rwa [h] at hi 
    Â· cases h3 _ h
    Â· cases h4 _ h
    Â· cases h1 _ h

-- An alternative approach to defining the sigma algebra generated by `{A}` is just
-- to use `measurable_space.generate_from`:
example (A : Set X) : MeasurableSpace X :=
  MeasurableSpace.generateFrom {A}

-- But the problem with that approach is that you don't get the actual sets
-- in the sigma algebra for free. Try this, to see what I mean!
example (A : Set X) :
    (MeasurableSpace.generateFrom {A}).MeasurableSet' = ({âˆ…, A, Aá¶œ, âŠ¤} : Set (Set X)) :=
  by
  ext B
  unfold MeasurableSpace.generateFrom
  simp
  constructor
  Â· intro h
    induction' h with A' hA' C hC1 hC2 f hf1 hf2
    Â· simp at hA' ; right; left; assumption
    Â· left; rfl
    Â· rcases hC2 with (rfl | rfl | rfl | rfl) <;> finish
    Â· dsimp at hf2 
      exact (genBy X A).measurable_set_iUnion f hf2
  Â· rintro (rfl | rfl | rfl | rfl)
    Â· apply MeasurableSpace.GenerateMeasurable.empty
    Â· apply MeasurableSpace.GenerateMeasurable.basic; simp
    Â· apply MeasurableSpace.GenerateMeasurable.compl;
      apply MeasurableSpace.GenerateMeasurable.basic; simp
    Â· rw [show (Set.univ : Set X) = âˆ…á¶œ by simp]
      apply MeasurableSpace.GenerateMeasurable.compl; apply MeasurableSpace.GenerateMeasurable.empty

